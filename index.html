<script>
// Open me at file:///C:/cygwin64/home/kdemarest/caverescue/index.html
</script>
<script
	src="https://code.jquery.com/jquery-3.1.1.js"
	integrity="sha256-16cdPddA6VdVInumRGo6IbivbERE8p7CQR3HzTBuELA="
	crossorigin="anonymous"></script>
<script src="http://code.responsivevoice.org/responsivevoice.js"></script>

<style>
#chat {
	height: 200px;
	font-size:12px;
	border: 1px solid black;
	overflow: hidden;
}
#chat p {
	margin-top:0em;
	margin-bottom:0em;
}
#orders {
	height: 200px;
	font-size:12px;
	border: 1px solid black;
	overflow: hidden;
}
#orderSummary {
	background-color: lightblue;
	font-size:10px;
	border: 1px solid black;
	overflow: hidden;
}
a.choice {
	color: blue;
	text-decoration: underline;
	cursor: pointer;
}
a.choice:hover {
	background-color: gray;
	cursor: pointer;
}
#mapCell {
	border: 1px solid black;
}
#map {
	background: #FF0;
}

</style>

<script>
let game = null;

Array.prototype.joinMember = function(member,delimeter) {
	let s = this.length > 0 ? this[0][member] : '';
	for( let i=1 ; i<this.length ; ++i ) {
		s += delimeter + this[i][member];
	}
	return s;
}

function hrTime(t) {
	function lpad(n) {
		return (n < 10 ? '0'+n : n);
	}
	return lpad(Math.floor(t/(60*60)))+':'+lpad(Math.floor(t/60))+':'+lpad(t % 60);
}

function query(a,fn) {
	var result = [];
	$.each(a,function(index,item) {
		let n = fn(item);
		if( n!==false ) { result.push(n); }
	});
	return result;
}

class Chat {
	constructor() {
		this.lastSpeaker = '';
	}
	add(source,message) {
		var person = game.mission.personFindWhere('name',source);
		responsiveVoice.speak(
			(this.lastSpeaker !== source && source !== 'You' ? "This is "+source+". " : '')+message,
			"UK English Male",
			person?{pitch:person.pitch}:undefined
		);
		this.lastSpeaker = source;
		let s = "<p style='background-color:red;'>" + hrTime(game.time) + ' ' + source + ': ' + message + "</p>";
		$(s)
		.prependTo("#chat")
		.animate(
			{ backgroundColor:'white' },
			{
				duration: 4000,
				step: function(now,tween) {
					//$(this).css()
				},
				complete: function() {
					$(this).css({backgroundColor:'white'});
				}
			}
		);
	}
}

function Renderer(c) {
	let xMin;
	let xMax;
	let yMin;
	let yMax;
	let xLen;
	let yLen;
	let xCtr;
	let yCtr;
	let xScale;
	let yScale;
	let zoom = {xOfs: 0, yOfs: 0, scale: 1.0};
	this.renderList = [];
	let nodeArrange = {};

	this.dimensionsCalc = function() {
		xMin = 999999;
		xMax = -999999;
		yMin = 999999;
		yMax = -999999;
		$.each(this.renderList,function(index,entity) {
			var e = entity["extent"](c)
			xMin = Math.min(xMin,e.x);
			xMax = Math.max(xMax,e.x);
			yMin = Math.min(yMin,e.y);
			yMax = Math.max(yMax,e.y);
			if( e.ex ) { xMin = Math.min(xMin,e.ex); xMax = Math.max(xMax,e.ex); }
			if( e.ey ) { yMin = Math.min(yMin,e.ey); yMax = Math.max(yMax,e.ey); }
		});
		xLen = xMax-xMin;
		yLen = yMax-yMin;
		xCtr = (xMin+xMax)/2;
		yCtr = (yMin+yMax)/2;
		xScale = (xMax-xMin)/c.canvas.width;
		yScale = (yMax-yMin)/c.canvas.height;
		if( xScale > yScale ) {
			yLen *= xScale/yScale;
			yMin = yCtr - yLen/2;
			yMax = yCtr + yLen/2;
			yScale = xScale;
		}
		else {
			xLen *= yScale/xScale;
			xMin = xCtr - xLen/2;
			xMax = xCtr + xLen/2;
			xScale = yScale;
		}
		xMargin = 0.10;	// normalized percentage
		yMargin = 0.10;	// normalized percentage
		xMin -= xLen*xMargin;
		xMax += xLen*xMargin;
		yMin -= yLen*yMargin;
		yMax += yLen*yMargin;
		c.dimensions = {
			xScale: xScale, yScale: yScale,
			xCtr: xCtr, yCtr: yCtr,
			xLen: xLen, yLen: yLen,
			xMargin: xMargin, yMargin: yMargin
		}
		this.scale = function() { return xScale; }
		c.xLoc = function(x) {
			return (x-zoom.xOfs)/xScale*zoom.scale;
			//let xPct = (x-xMin)/(xMax-xMin);
			//return xPct / xScale;
		}
		c.yLoc = function(y) {
			return (y-zoom.yOfs)/yScale*zoom.scale;
			//let yPct = (y-yMin)/(yMax-yMin);
			//return yPct / yScale;
		}
	}
	this.renderSurvey = function(survey) {
		let e = survey.extent(c);
		c.drawImage(survey.image,c.xLoc(0),c.yLoc(0),c.xLoc(e.ex),c.yLoc(e.ey));
	}
	this.renderNode = function(node) {
		let e = node.extent(c);
		let radius = 10;
		let textHeight = 14;
		c.beginPath();
		c.strokeStyle="#000000";
		c.arc(c.xLoc(e.x),c.yLoc(e.y), radius, 0, Math.PI*2, true);
		c.stroke();
		c.fillStyle = "black";
		c.font = "bold "+textHeight+"px Arial";
		c.textAlign = "center";
		c.fillText(node.id, c.xLoc(e.x), c.yLoc(e.y)+textHeight/2);
	}
	this.renderPerson = function(person) {
		var nodeId = person.nodeId;
		if( nodeArrange[nodeId] == undefined ) {
			nodeArrange[nodeId] = 0;
		}
		else {
			nodeArrange[nodeId] +=1;
		}
		let xOfs = Math.cos(nodeArrange[nodeId]/8*Math.PI*2);
		let yOfs = Math.sin(nodeArrange[nodeId]/8*Math.PI*2);
		var e = person.extent(c);
		let textHeight = 14;
		c.fillStyle = person.isPatient ? "red" : "blue";
		c.font = "bold "+textHeight+"px Arial";
		c.textAlign = "center";
		c.fillText(person.name[0], c.xLoc(e.x)+xOfs*textHeight, c.yLoc(e.y)+yOfs*textHeight);
	}
	this.render = function(c) {
		nodeArrange = {};
		this.dimensionsCalc(c);
		$.each(this.renderList,function(index,entity) {
			entity["render"](c);
		});

	}
	return this;
}

class Survey {
	constructor(survey,onLoad) {
		this.image = new Image();
		this.image.src = survey.url;
		this.dimensions = { x:0, y:0, ex:100, ey:100 };
		let self = this;
		this.image.onload = function() {
			self.dimensions = { x:0, y:0, ex:this.width, ey:this.height };
			self.loaded = true;
			onLoad(this.width,this.height);
		};
	}
	extent() {
		return this.dimensions;
	}
	render() {
		game.renderer.renderSurvey(this);
	}

}

class Map {
	constructor() {
		this.canvas = document.getElementById("map");
		this.context = this.canvas.getContext("2d");
		var self = this;
		function getMousePos(canvas, evt) {
			var rect = self.canvas.getBoundingClientRect();
			var w = Math.min((rect.right-rect.left),game.survey.image.width/game.renderer.scale());
			var h = Math.min((rect.bottom-rect.top),game.survey.image.height/game.renderer.scale());
			return {
				x: Math.floor((evt.clientX - rect.left)/w*1000),
				y: Math.floor((evt.clientY - rect.top)/h*1000)
			};
		}
		this.canvas.addEventListener('mousemove', function(evt) {
			var mousePos = getMousePos(self.canvas, evt);
			$('#coords').html('('+mousePos.x+','+mousePos.y+')');
			let radius = 2;
			self.context.beginPath();
			self.context.strokeStyle="#ff0000";
			var w = game.survey.image.width;
			var h = game.survey.image.height;
			self.context.arc(self.context.xLoc(mousePos.x*w/1000),self.context.yLoc(mousePos.y*h/1000), radius, 0, Math.PI*2, true);
			self.context.stroke();

		}, false);	
	}
	render() {
		this.context.canvas.width = $("#mapCell").innerWidth()-2;
		this.context.canvas.height = $("#mapCell").innerHeight()-2;
		game.renderer.render(this.context);
	}
	tick() {
		this.render();
	}

}

class Orders {
	constructor() {
		this.order = {};
		this.state = -1;	// 0 means populate, 1/2/3 = stages, 4 means execute
		this.choices = {};
		this.reset();
	}
	reset() {
		this.state = 0;
		this.order.who = "";
		this.order.verb = "";
		this.order.where = "";
		var colId = '#order_choices';
		$(colId).empty();
	}
	populate() {
		this.choices.personList = query(game.mission.personList,function(person) {
			return (!person.isPatient && !person.isYou ? person.name : false);
		});
		this.choices.verb = ['search','evacuate'];
		this.choices.landmark = query(game.mission.nodeList,function(node) {
			return node.name ? node.name : false;
		});
	}
	present(column,choices) {
		var colId = '#order_choices';
		$(colId).empty();
		var self = this;
		$.each(choices,function(index,choice) {
			$("<a src='javascript:void 0' class='choice'>"+choice+"</a>")
				.appendTo(colId)
				.click( function() {
					if( self.state == 1 ) { self.order.who = choice; }
					if( self.state == 2 ) { self.order.verb = choice; }
					if( self.state == 3 ) { self.order.where = game.mission.nodeFindWhere('name',choice).id; }
					self.stateAdvance();
				})
				.append("<br />");
		});
	}
	execute() {
		game.chat.add("You",this.summary());
		game.mission.executeOrder(this.order);
		this.reset();
	}
	stateAdvance() {
		this.populate();
		this.state += 1;
		if( this.state >= 4 ) {
			this.execute();
			return;
		}
		let choiceArrayList = [this.choices.personList, this.choices.verb, this.choices.landmark];
		this.present(this.state,choiceArrayList[this.state-1]);
		this.summarize();
	}
	summary() {
		return this.order.who+' '+this.order.verb+(this.order.where?' '+game.mission.nodeList[this.order.where].name:'');
	}
	summarize() {
		$('#orderSummary').html($.trim(this.summary()) || '&nbsp;');
	}
	tick() {
		if( this.state == 0 ) {
			this.stateAdvance();
		}
		this.summarize();
	}
}

class Game {
	constructor(data){
		this.mission = data.mission;
		this.time = 0;
		this.timeSpeed = 1.0;
		this.pathFinder = new PathFinder(this.mission.nodeList);
		this.chat = new Chat();
		this.orders = new Orders();
		this.survey = new Survey(
			data.mission.survey,
			function(w,h) {
				data.mission.nodesCorrect(w,h);
			}
		);
		this.map = new Map();
		this.renderer = new Renderer(this.map.context);
	}
	tick() {
		this.time++;
		this.mission.mapPopulate();
		this.orders.tick();
		this.mission.tick();
		this.map.tick();
	}
}

class Person {
	constructor(data) {
		this.name = data.name;
		this.nodeId = data.nodeId;
		this.isPatient = data.isPatient;
		this.injuryList = data.injuryList;
		this.action = data.action;
		this.objective = data.objective;
		this.destinationNodeId = null;
		this.chatBuffer = [];
		//this.chatBuffer.push(this.textStatus());
	}
	extent() {
		let x = game.mission.nodeFindWhere('id',this.nodeId).x;
		let y = game.mission.nodeFindWhere('id',this.nodeId).y;
		return { x:x, y:y };
	}
	render() {
		game.renderer.renderPerson(this);
	}
	textStatus() {
		let s = [];
		s.push( "This is "+this.name+" at node "+this.nodeId+"." );
		if( this.injuryList ) { s.push( "I have a "+this.injuryList[0].type+' to my '+this.injuryList[0].location+'.'); }
		s.push( "My objective is "+this.objective+(this.destinationNodeId?' '+this.destinationNodeId:'')+".");
		return s.join(' ');
	}
	chat(message) {
		game.chat.add( this.name, message );
	}
	onOrder(order) {
		var self = this;
		if( order.verb == 'evacuate' ) {
			self.evacuatingPersonId = undefined;
			this.chatBuffer.push("Evacuating now.");
		}
		if( order.verb == 'search' ) {
			this.chatBuffer.push("I will search to "+game.mission.nodeFindWhere('id',order.where).name+".");
		}
	}
	onFindPatient(patientsFound) {
		let id = this.id;
		let node = game.mission.nodeFindWhere('id',this.nodeId);
		this.chatBuffer.push("I found patient"+(patientsFound.length>1?'s':'')+' '+patientsFound.joinMember('name',', ')+(node&&node.name?' in '+node.name:'')+'!');
		$.each( patientsFound, function(index,person) {
			person.foundByPersonId = id;
		});
		let patientsRemaining = query(game.mission.personList,function(person) {
			return person.isPatient && !person.foundByPersonId ? person : false;
		});
		if( patientsRemaining.length <= 0 ) {
			this.objective = 'wait';
			this.destinationNodeId = null;
			this.chatBuffer.push("Awaiting further instructions.");
		}
		else {
			this.chatBuffer.push("Should I evac, or keep searching for others?");
			this.objective = 'wait';
			this.destinationNodeId = null;
		}
	}
	onArriveAt() {
		if( this.isPatient && this.nodeId == game.mission.lookup.node.commandNodeId ) {
			let rescuer = game.mission.personFindWhere('evacuatingPersonId',this.id);
			(rescuer || this).chatBuffer.push("Patient "+this.name+" has been rescued!");
		}
	}
	act() {
		var self = this;
		let effort = 0.01;
		let duration = 1;
		if( this.objective == 'wait' ) {
			// Do nothing.
		}
		if( this.objective == 'search' ) {
			duration = 2;
		}
		if( this.objective == 'evacuate' ) {
			duration = 2;
			if( !this.evacuatingPersonId ) {
				$.each(game.mission.personList,function(personId,person) {
					if( !self.isPatient && person.isPatient && person.nodeId == self.nodeId ) {
						self.chatBuffer.push("I am evacuating "+person.name+" to "+game.mission.nodeList[self.destinationNodeId].name+".");
						self.evacuatingPersonId = person.id;
						person.objective = 'evacuate';
						person.destinationNodeId = self.destinationNodeId;
					}
				});
			}
		}
		if( this.objective == 'asking' ) {
			duration = 2;
		}
		if( this.destinationNodeId !== null && this.destinationNodeId != this.nodeId ) {
			let path = game.pathFinder.find(this.nodeId,this.destinationNodeId);
			if( path !== false && path.length > 1 && this.nodeId != path[1] ) {
				//this.chatBuffer.push("path: "+path.join('->'));
				this.nodeId = path[1];
				this.onArriveAt(this.nodeId);
			}
		}
		if( !this.isPatient ) {
			let patientsFound = query(game.mission.personList,function(person) {
				return self.nodeId == person.nodeId && person.isPatient && !person.foundByPersonId ? person : false;
			});
			if( patientsFound.length > 0 ) {
				this.onFindPatient(patientsFound);
			}
		}
	}
	tick() {
		this.act();
		while( this.chatBuffer.length > 0 ) {
			let message = this.chatBuffer.shift();
			if( typeof(message) == 'function' ) {
				message = message(this);
			}
			this.chat(message);
		}
	}
}

class Node {
	constructor(data) {
		this.id = data.id;
		this.name = data.name;
		this.isCommand = data.isCommand;
		this.isEntrance = data.isEntrance;
		this.x = data.x;
		this.y = data.y;
		this.connectionList = data.connectionList;
	}
	extent() {
		return { x: this.x, y: this.y };
	}
	render() {
		game.renderer.renderNode(this);
	}
}
class PathFinder {
	constructor(nodeList,personList) {
		this.nodeList = nodeList;
		this.personList = personList;
	}
	find(startNodeId,endNodeId) {
		var nodeList = this.nodeList;
		let from = {};
		if( !nodeList[startNodeId] ) throw "pathfind no such starting node "+startNodeId;
		if( !nodeList[endNodeId] ) throw "pathfind no such end node "+endNodeId;

		let count = 0;
		function advance(nodeId,fromNodeId) {
			if( !nodeList[nodeId] ) throw "pathfind no such node "+nodeId;
			from[nodeId] = fromNodeId;
			count += 1;
			$.each(nodeList[nodeId].connectionList,function(index,toNodeId) {
				if( !nodeList[toNodeId] ) throw "pathfind no such connection from "+nodeId+" to "+toNodeId;
				let toNode = nodeList[toNodeId];
				if( toNode.id != fromNodeId && from[toNode.id] === undefined ) {
					advance(toNodeId,nodeId);
				}
			});
		}
		advance(startNodeId,-1);
		let path = [];
		let nodeId = endNodeId;
		if( from[nodeId] === undefined ) {
			return false;
		}
		do {
			path.unshift(nodeId);
			nodeId = from[nodeId];
		} while( nodeId != startNodeId && nodeList[nodeId] && from[nodeId] !== undefined );
		path.unshift(nodeId);
		return path;
	}
}
class Mission {
	constructor(data){
		this.name = data.name;
		this.survey = data.survey;
		this.personList = $.extend(true,{},data.personList);
		this.nodeList = $.extend(true,{},data.nodeList);
		this.lookup = {
			person: {},
			node: {
				entranceNodeId: this.nodeFindWhere('isEntrance',true).id,
				commandNodeId: this.nodeFindWhere('isCommand',true).id
			}
		};

		$.each(this.personList,function(index,person) {
			person.pitch = 0.5+Math.random()*1.0;
		});
	}
	mapPopulate() {
		game.renderer.renderList = [];
		if( game.survey.loaded ) {
			game.renderer.renderList.push(game.survey);
			$.each(this.personList,function(index,person) {
				game.renderer.renderList.push(person);
			});
			$.each(this.nodeList,function(index,node) {
				game.renderer.renderList.push(node);
			});
		}
	}
	personFindWhere(member,value) {
		var found = false;
		$.each( this.personList, function(personId,person) {
			if( person[member] == value ) {
				found = person;
				return false;
			}
		});
		return found;
	}
	nodeFindWhere(member,value) {
		var found = false;
		$.each( this.nodeList, function(nodeId,node) {
			if( node[member] == value ) {
				found = node;
				return false;
			}
		});
		return found;
	}
	nodesCorrect(surveyWidth,surveyHeight) {
		if( !this.corrected ) {
			$.each( this.nodeList, function(nodeId,node) {
				node.x = node.x * surveyWidth / 1000.0;
				node.y = node.y * surveyHeight / 1000.0;
			});
			this.corrected = true;
		}
	}
	executeOrder(order) {
		let person = this.personFindWhere('name',order.who);
		let node = this.nodeFindWhere('id',order.where);
		if( order.verb == 'search' || order.verb == 'evacuate') {
			person.objective = order.verb;
			person.destinationNodeId = node.id;
			person.onOrder(order);
		}
	}
	tick() {
		$.each( this.personList, function(personId,person) {
			person.tick();
		});
		$("#time").text(hrTime(game.time));
	}
}
function giveIds(obj) {
	$.each(obj,function(key,value) {
		obj[key].id = key;
	});
	return obj;
}

function getMissionList() {
	return [
	new Mission({
		name: "proof of concept",
		survey: {
			//url: "WhirlpoolCave.png"
			url: "WhirlpoolCave40PctCropped.png"
		},
		personList: giveIds({
			'You': new Person({
				name: "You",
				gender: 'm',
				isYou: true,
				nodeId: 1,
				isPatient: false,
				objective: "command"
			}),
			'BA': new Person({
				name: "Billabob Armadillo",
				gender: 'm',
				nodeId: 1,
				isPatient: false,
				objective: "wait"
			}),
			'G': new Person({
				name: "Greg",
				gender: 'm',
				nodeId: 1,
				isPatient: false,
				objective: "wait"
			}),
			'A': new Person({
				name: "Allan",
				gender: 'm',
				nodeId: 1,
				isPatient: false,
				objective: "wait"
			}),
			'S': new Person({
				name: "Smeerfly",
				gender: 'm',
				nodeId: 3,
				isPatient: true,
				injuryList: [{location: 'left ankle', type: 'sprain'}],
				objective: "wait"
			})
		}),
		nodeList: giveIds({
			'1': new Node({
				name: "Incident Command",
				isCommand: true,
				x: 250,
				y: 880,
				connectionList: [
					'en'
				]
			}),
			'en': new Node({
				name: "Entrance",
				isEntrance: true,
				x: 67,
				y: 925,
				connectionList: [
					1, 'nb'
				]
			}),
			'nb': new Node({
				name: "Natural Bridge",
				x: 111,
				y: 839,
				connectionList: [
					'en', '2b'
				]
			}),
			'2b': new Node({
				x: 188,
				y: 667,
				connectionList: [
					'nb', '2c'
				]
			}),
			'2c': new Node({
				x: 254,
				y: 613,
				connectionList: [
					'2b', '2d'
				]
			}),
			'2d': new Node({
				x: 293,
				y: 594,
				connectionList: [
					'2c', '2e'
				]
			}),
			'2e': new Node({
				x: 352,
				y: 643,
				connectionList: [
					'2d', '3'
				]
			}),
			'3': new Node({
				name: "Travis Country Room",
				x: 424,
				y: 570,
				connectionList: [
					'2e', 'rr'
				]
			}),
			'rr': new Node({
				name: "Red Room",
				x: 380,
				y: 388,
				connectionList: [
					3
				]
			})
		})
	})
	];
}

$(document).ready(function() {
	game = new Game({
		mission: getMissionList()[0]
	});
	game.tick();
	let timer = setInterval(
		function() { game.tick(); }, 1000
	)
});
</script>

<div><span id="time"></span>&nbsp;&nbsp;<span id="coords"></span></div>
<table style="width: 100%">
<tr>
<td rowspan=3>
	<div id='mapCell' style="width:100%; height:500px;">
	<canvas id="map" width="200" height="120"></canvas>
	</div>
</td>
<td style="width: 40%">
<div id="whiteboard">WHITEBOARD</div>
</td>
</tr><tr>
<td style="width: 40%">
<div id="chat">	</div>
</td>
</tr><tr>
<td style="width: 40%">
<div id="orders">
<div id="orderSummary"></div>
<div id="order_choices"></div>
</div>
</td>
</tr></table>
