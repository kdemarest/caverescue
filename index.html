<script>
// Open me at file:///C:/cygwin64/home/kdemarest/caverescue/index.html
</script>
<script
	src="https://code.jquery.com/jquery-3.1.1.js"
	integrity="sha256-16cdPddA6VdVInumRGo6IbivbERE8p7CQR3HzTBuELA="
	crossorigin="anonymous"></script>
<script src="http://code.responsivevoice.org/responsivevoice.js"></script>

<style>
#whiteboard {
	height: 200px;
}
#chat {
	height: 160px;
	font-size:12px;
	border: 1px solid black;
	overflow: hidden;
}
#chat p {
	margin-top:0em;
	margin-bottom:0em;
}
#orders {
	height: 100px;
	font-size:12px;
	border: 1px solid black;
	overflow: hidden;
}
#orderSummary {
	background-color: lightblue;
	font-size:12px;
	border: 0px solid black;
	height: 14px;
	overflow: hidden;
}
#orderChoices {
	font-size:10px;
	overflow-y: scroll;
	height: calc( 100% - 14px );
}
a.choice {
	color: blue;
	text-decoration: underline;
	cursor: pointer;
}
a.choice:hover {
	background-color: gray;
	cursor: pointer;
}
span.disableChoice {
	color: grey;
}
#mapCell {
	border: 1px solid black;
}
#map {
	background: #FF0;
}

</style>

<script>
let game = null;

Array.prototype.joinMember = function(member,delimeter) {
	let s = this.length > 0 ? this[0][member] : '';
	for( let i=1 ; i<this.length ; ++i ) {
		s += delimeter + this[i][member];
	}
	return s;
}

function query(a,fn) {
	var result = [];
	$.each(a,function(index,item) {
		let n = fn(item,index);
		if( n!==false ) { result.push(n); }
	});
	return result;
}

function getMapDistance(entity1,entity2) {
	let dx = (entity1.x-entity2.x)/game.mission.survey.mapScale;
	let dy = (entity1.y-entity2.y)/game.mission.survey.mapScale;
	return Math.sqrt((dx*dx)+(dy*dy));
}
function getDistance(entity1,entity2) {
	let dx = entity1.x-entity2.x;
	let dy = entity1.y-entity2.y;
	return Math.sqrt((dx*dx)+(dy*dy));
}
function getRadians(source,target) {
	let dx = target.x - source.x;
	let dy = target.y - source.y;
	return Math.atan2(dy,dx);
}
var debug = {
	showNodes: false,
	showPatient: false,
	log: function(message) { console.log(message); }
};

var Effort = {
	walk: 1.0,
	talk: 0.1
}

let MoveMode = giveIds({
	squeeze: { speed: 0.10, effortPerSecond: 3.0, pass: false },
	crawl: { speed: 0.25, effortPerSecond: 1.5, pass: true },
	stoop: { speed: 0.50, effortPerSecond: 1.2, pass: true },
	walk: { speed: 1.00, effortPerSecond: 1.0, pass: true },
	vertical: { speed: 0.10, effortPerSecond: 3.0, pass: false },
	crack: { speed: 0.50, effortPerSecond: 1.5, pass: false },
	splash: { speed: 0.90, effortPerSecond: 1.0, pass: true },
	wade: { speed: 0.70, effortPerSecond: 1.1, pass: true },
	swim: { speed: 0.30, effortPerSecond: 1.4, pass: true },
	lowair: { speed: 0.15, effortPerSecond: 1.0, pass: false }
});

var BodyLimits = {
	staminaNormal: 1.0,
	staminaTired: 0.25,
	staminaExhausted: 0.05,
	temperatureNormal: 98.6,
	temperatureHypothermia: 95
};

var BodyLevels = {
	staminaTired: 0.18,
	staminaExhausted: 0.02,
	temperatureHypothermia: 93,
	temperatureHypothermiaSevere: 82
};

let IssueType = giveIds({
	lost: {
		speed: 1.0,
		effort: 1.0,
		test: function() { return this.isLost; },
		describe: function() {
			return "is lost";
		}
	},
	exhausted: {
		speed: 0.5,
		effort: 2.0,
		test: function() { return this.body.stamina <= BodyLimits.staminaExhausted; },
		describe: function() {
			return "is exhausted";
		}
	},
	tired: {
		speed: 0.5,
		effort: 1.0,
		test: function() { return this.body.stamina <= BodyLimits.staminaTired && this.body.stamina > BodyLimits.staminaExhausted; },
		describe: function() {
			return "is tired";
		}
	},
	hypothermic: {
		speed: 0.7,
		effort: 2.0,
		test: function() { return this.body.temperature <= BodyLimits.temperatureHypothermia; },
		describe: function() {
			return "is hypothermic";
		}
	}
});

let InjurySeverity = giveIds({
	canWalk: { speed: 1.0, effort: 1.0 },
	canWalkPainfully: { speed: 0.5, effort: 2.0 },
	canDragSelf: { speed: 0.2, effort: 4.0 },
	mustBeHelped: { speed: 0.5, effort: 3.0 },
	requiresStretcher: { speed: 0.0, effort: 0.0 },
	requiresStretcherAndSpine: { speed: 0.0, effort: 0.0 }
});

class Chat {
	constructor(peopleFind) {
		this.lastSpeakerId = false;
		this.peopleFind = peopleFind;
	}
	add(speaker,message) {
		responsiveVoice.speak(
			(this.lastSpeakerId !== speaker.id && !speaker.isYou ? "This is "+speaker.name+". " : '')+message,
			"UK English Male",
			speaker?{pitch:speaker.pitch}:undefined
		);
		this.lastSpeakerId = speaker.id;
		let s = "<p style='background-color:red;'>" + game.clock.readable() + ' ' + speaker.name + ': ' + message + "</p>";
		$(s)
		.prependTo("#chat")
		.animate(
			{ backgroundColor:'white' },
			{
				duration: 4000,
				step: function(now,tween) {
					//$(this).css()
				},
				complete: function() {
					$(this).css({backgroundColor:'white'});
				}
			}
		);
	}
	tick() {
	}
}

function Renderer() {
	let c = null;
	let xMin;
	let xMax;
	let yMin;
	let yMax;
	let xLen;
	let yLen;
	let xCtr;
	let yCtr;
	let xScale;
	let yScale;
	let zoom = {xOfs: 0, yOfs: 0, scale: 1.0};
	let nodeArrange = {};

	this.setContext = function(context) {
		c = context;
	}
	this.dimensionsCalc = function(renderList) {
		if( renderList.length <= 0 ) {
			this.scale = undefined;
		}
		xMin = 999999;
		xMax = -999999;
		yMin = 999999;
		yMax = -999999;
		$.each(renderList,function(index,entity) {
			var e = entity["extent"](c)
			xMin = Math.min(xMin,e.x);
			xMax = Math.max(xMax,e.x);
			yMin = Math.min(yMin,e.y);
			yMax = Math.max(yMax,e.y);
			if( e.ex ) { xMin = Math.min(xMin,e.ex); xMax = Math.max(xMax,e.ex); }
			if( e.ey ) { yMin = Math.min(yMin,e.ey); yMax = Math.max(yMax,e.ey); }
		});
		xLen = xMax-xMin;
		yLen = yMax-yMin;
		xCtr = (xMin+xMax)/2;
		yCtr = (yMin+yMax)/2;
		xScale = (xMax-xMin)/c.canvas.width;
		yScale = (yMax-yMin)/c.canvas.height;
		if( xScale > yScale ) {
			yLen *= xScale/yScale;
			yMin = yCtr - yLen/2;
			yMax = yCtr + yLen/2;
			yScale = xScale;
		}
		else {
			xLen *= yScale/xScale;
			xMin = xCtr - xLen/2;
			xMax = xCtr + xLen/2;
			xScale = yScale;
		}
		xMargin = 0.10;	// normalized percentage
		yMargin = 0.10;	// normalized percentage
		xMin -= xLen*xMargin;
		xMax += xLen*xMargin;
		yMin -= yLen*yMargin;
		yMax += yLen*yMargin;
		c.dimensions = {
			xScale: xScale, yScale: yScale,
			xCtr: xCtr, yCtr: yCtr,
			xLen: xLen, yLen: yLen,
			xMargin: xMargin, yMargin: yMargin
		}
		this.scale = function() { return xScale; }
		c.scaleLength = function(length) {
			return length/xScale;
		}
		c.xLoc = function(x) {
			return (x-zoom.xOfs)/xScale*zoom.scale;
			//let xPct = (x-xMin)/(xMax-xMin);
			//return xPct / xScale;
		}
		c.yLoc = function(y) {
			return (y-zoom.yOfs)/yScale*zoom.scale;
			//let yPct = (y-yMin)/(yMax-yMin);
			//return yPct / yScale;
		}
	}
	this.textHeightStandard = function(size) {
		return Math.floor(Math.min(16,Math.max(6,c.scaleLength(size*2))));
	}
	this.visualPlacement = function(renderList) {
		let tolerance = this.textHeightStandard(12)*1.5;
		let p = [];
		$.each(renderList,function(index,entity) {
			if( !(entity instanceof Person) ) {
				return;
			}
			if( entity.visual.x === false ) {
				entity.visual.x = entity.x;
			}
			if( entity.visual.y === false ) {
				entity.visual.y = entity.y;
			}
			p.push(entity);
		});

		p.sort(function(a,b) {
			if( a.lastMoveTime == b.lastMoveTime ) {
				return a.id < b.id ? 1 : -1;
			}
			return a.lastMoveTime < b.lastMoveTime ? 1 : -1;
		});

		let overlap;
		let timeout = 1;
		do {
			overlap = false;
			for( let i=0 ; i<p.length ; ++i ) {
				let xOld = p[i].visual.x;
				let yOld = p[i].visual.y;
				let d = getDistance(p[i].visual,p[i]);
				let triedToward = false;
				if( d > 0.01 ) {
					let r = getRadians(p[i].visual,p[i]);
					let travel = p[i].isActivelyMoving() ? Math.max((d-tolerance)*0.8,1.0) : Math.min(d,1.0);
					p[i].visual.x += Math.cos(r)*travel;
					p[i].visual.y += Math.sin(r)*travel;
					triedToward = true;
				}
				// Now move away from any overlaps.
				if( !p[i].isActivelyMoving() ) {
					for( let j=i+1 ; j<p.length ; ++j ) {
						if( p[j].isActivelyMoving() ) {
							continue;
						}
						let d = getDistance(p[i].visual,p[j].visual);
						if( d < tolerance && triedToward ) {
							// We tried to go toward our approved spot, but that caused an overlap
							// so we'll reset to where we started and hope that isn't an overlap.
							triedToward = false;
							p[i].visual.x = xOld;
							p[i].visual.y = yOld;
							d = getDistance(p[i].visual,p[j].visual);
						}

						if( d == 0 ) {
							p[i].visual.x -= Math.cos(p[i].visual.rand)*0.01;
							p[i].visual.y -= Math.sin(p[i].visual.rand)*0.01;
							d = getDistance(p[i].visual,p[j].visual);
						}
						if( d < tolerance ) {
							overlap = true;
							let r = getRadians(p[i].visual,p[j].visual);
							p[i].visual.x -= Math.cos(r)*2.0;
							p[i].visual.y -= Math.sin(r)*2.0;
							let d2 = getDistance(p[i].visual,p[j].visual);
						}
					}
				}
			}
		} while( overlap && --timeout>0 );
	}
	this.renderSurvey = function(survey) {
		let e = survey.extent(c);
		c.drawImage(survey.image,c.xLoc(0),c.yLoc(0),c.xLoc(e.ex),c.yLoc(e.ey));
	}
	this.renderNode = function(node) {
		let e = node.extent(c);
		let textHeight = this.textHeightStandard(12);
		let radius = Math.floor(textHeight/2+2);
		c.beginPath();
		c.arc(c.xLoc(e.x),c.yLoc(e.y), radius, 0, Math.PI*2, true);
		//c.strokeStyle="#000000";
		//c.stroke();
		c.fillStyle = 'rgba(255, 255, 255, 0.6)';
		c.fill();		
		c.fillStyle = "black";
		c.font = "bold "+textHeight+"px Arial";
		c.textAlign = "center";
		c.fillText(node.id, c.xLoc(e.x), c.yLoc(e.y)+textHeight/2);
	}
	this.renderPerson = function(person) {
		var nodeId = person.nodeId;
		if( nodeArrange[nodeId] == undefined ) {
			nodeArrange[nodeId] = 0;
		}
		else {
			nodeArrange[nodeId] +=1;
		}
		let xOfs = 0; //Math.cos(nodeArrange[nodeId]/8*Math.PI*2);
		let yOfs = 0; //Math.sin(nodeArrange[nodeId]/8*Math.PI*2);
		var e = person.visual;
		let textHeight = this.textHeightStandard(12);
		let radius = Math.floor(textHeight/2);

		c.beginPath();
		c.arc(c.xLoc(e.x),c.yLoc(e.y), radius, 0, Math.PI*2, true);
//		c.strokeStyle="#000000";
//		c.stroke();
		c.fillStyle = 'rgba(255, 255, 255, 0.8)';
		c.fill();		
		c.fillStyle = person.isPatient ? "red" : person.isAwaitingTraffic ? "gold" : "blue";
		c.font = "bold "+textHeight+"px Arial";
		c.textAlign = "center";
		c.fillText(person.name[0], c.xLoc(e.x)+xOfs*textHeight, c.yLoc(e.y)+textHeight/2.5+yOfs*textHeight);
	}
	this.render = function(renderList) {
		nodeArrange = {};
		this.dimensionsCalc(renderList);
		this.visualPlacement(renderList);
		$.each(renderList,function(index,entity) {
			entity["render"](c);
		});

	}
	return this;
}

class Survey {
	constructor(survey) {
		this.image = new Image();
		this.image.src = survey.url;
		this.dimensions = { x:0, y:0, ex:survey.width, ey:survey.height };
		let self = this;
		this.image.onload = function() {
			self.loaded = true;
		};
	}
	extent() {
		return this.dimensions;
	}
	render() {
		game.renderer.renderSurvey(this);
	}

}

class Map {
	constructor() {
		this.canvas = document.getElementById("map");
		this.context = this.canvas.getContext("2d");
		let self = this;
		function getMousePos(canvas, evt) {
			var rect = self.canvas.getBoundingClientRect();
			var w = Math.min((rect.right-rect.left),game.survey.image.width/game.renderer.scale());
			var h = Math.min((rect.bottom-rect.top),game.survey.image.height/game.renderer.scale());
			return {
				x: Math.floor((evt.clientX - rect.left)/w*1000),
				y: Math.floor((evt.clientY - rect.top)/h*1000)
			};
		}
		this.canvas.addEventListener('mousemove', function(evt) {
			if( !game.renderer.scale ) {
				// if this doesn't exist, then we haven't finished loading the survey nor
				// calculated the dimensions
				return;
			}
			var mousePos = getMousePos(self.canvas, evt);
			$('#coords').html('('+mousePos.x+','+mousePos.y+')');
			let radius = 2;
			self.context.beginPath();
			self.context.strokeStyle="#ff0000";
			var w = game.survey.image.width;
			var h = game.survey.image.height;
			self.context.arc(self.context.xLoc(mousePos.x*w/1000),self.context.yLoc(mousePos.y*h/1000), radius, 0, Math.PI*2, true);
			self.context.stroke();

		}, false);	
	}
	renderPrepare() {
		this.canvas = document.getElementById("map");
		this.context = this.canvas.getContext("2d");
		this.context.canvas.width = $("#mapCell").innerWidth()-2;
		this.context.canvas.height = $("#mapCell").innerHeight()-2;
	}
}

class Clock {
	constructor(rate) {
		this.time = 0.0;
		this.rate = rate;
		this.dt = 0.0;
		this.lastWallMoment = false;
	}
	hrTime(t) {
		function lpad(n) {
			return (n < 10 ? '0'+n : n);
		}
		return lpad(Math.floor(t/(60*60)))+':'+lpad(Math.floor(t/60))+':'+lpad(Math.floor(t) % 60);
	}
	readable() {
		return this.hrTime(this.time);
	}
	now() {
		return new Date().getTime();
	}
	start() {
		this.lastWallMoment = this.now();
	}
	advance() {
		var wallMoment = this.now();
		this.dt = (wallMoment - this.lastWallMoment)/1000 * this.rate;
		this.time += this.dt;
		this.lastWallMoment = wallMoment;
	}
}

class Team {
	constructor(name,leader) {
		this.name = name;
		this.leader = leader;
	}
};

class Person {
	constructor(data) {
		this.name = data.name;
		this.nodeId = data.nodeId;
		this.land = null;
		this.x = false;	// position is unknown until we have a node list
		this.y = false;
		this.lastMoveTime = 0.0;
		this.isYou = data.isYou;
		this.isPatient = data.isPatient;
		this.isLost = data.isLost;
		this.toAssess = null;
		let b = data.body || {};
		this.body = {
			stamina: b.stamina || BodyLimits.staminaNormal,
			temperature: b.temperature || BodyLimits.temperatureNormal,
			injuryList: b.injuryList || []
		};
		this.action = data.action;
		this.orderList = [];
		this.objective = data.objective;
		this.destinationNodeId = false;
		this.destinationNextNodeId = false;
		this.nextNode = false;
		this.chatBuffer = [];
		this.actionList = [];
		//this.chatBuffer.push(this.textStatus());
	}
	setPosition(position) {
		this.x = position.x;
		this.y = position.y;
	}
	extent() {
		return { x:this.x, y:this.y };
	}
	render() {
		game.renderer.renderPerson(this);
	}
	textStatus() {
		let s = [];
		s.push( "This is "+this.name+" at node "+this.nodeId+"." );
//		if( this.body.injuryList ) { s.push( "I have a "+this.body.injuryList[0].desc+' to my '+this.body.injuryList[0].location+'.'); }
		s.push( "My objective is "+this.objective+(this.destinationNodeId?' '+this.destinationNodeId:'')+".");
		return s.join(' ');
	}
	chat(message) {
		game.chat.add( this, message );
	}
	evacuatingPersonCouple(person) {
		this.evacuatingPersonDecouple();
		debug.log(this.name+' setting evac person');
		this.evacuatingPerson = person;
		person.objective = 'evacuate';
		person.destinationSet(this.destinationNodeId);
	}
	evacuatingPersonDecouple() {
		if( this.evacuatingPerson ) {
			debug.log(this.name+' clearing evac person');
			this.actionClear('evacuate');
			this.evacuatingPerson.objective = 'wait';
			this.evacuatingPerson.destinationClear();
			this.evacuatingPerson = undefined;
		}
	}
	destinationSet(nodeId) {
		if( this.nextNode && !this.isAwaitingTraffic ) {
			this.actionClear('move');
			this.destinationNextNodeId = nodeId;
			this.nextNode = false;
			return;
		}
		if( nodeId != this.destinationNodeId ) {
			this.actionClear('move');
			this.destinationNextNodeId = false;
			this.destinationNodeId = nodeId;
			this.nextNode = false;
		}
	}
	destinationClear(nodeId) {
		if( this.nextNode ) {
			this.destinationNodeId = this.nextNode.id;
			this.destinationNextNodeId = false;
			return;
		}
		this.actionClear('move');
		this.destinationNodeId = false;
		this.destinationNextNodeId = false;
		this.nextNode = false;
	}
	actionClear(actionId) {
		if( this.actionList[0] && this.actionList[0].id == actionId ) {
			var abort = this.actionList.shift();
			debug.log(this.name+' aborting '+actionId);
			abort.onAbort.apply(this,[abort]);
		}
	}
	isMoving() {
		return this.actionList.length && this.actionList[0].id=='move';
	}
	isActivelyMoving() {
		return this.isMoving() && !this.isAwaitingTraffic;
	}
	orderAdd(order) {
		// WARNING: we will need to put in some smarts so that certain pre-existing
		// orders get zapped when certain orders come in. For example, evac, search and return
		// are all mutually-exclusive.
		this.orderList.push($.extend(true,{},order));
	}
	onOrder(order) {
		this.evacuatingPersonDecouple();
		if( order.verb == 'form' ) {
			this.people.teamForm('team '+order.person.name,order.node,order.roster);
		}
		if( order.verb == 'evacuate' ) {
			this.objective = order.verb;
			order.node = game.mission.lookup.node.command;
			this.destinationSet(order.node.id);
			this.chatBuffer.push("Evacuating now.");
		}
		if( order.verb == 'search' ) {
			this.objective = order.verb;
			this.destinationSet(order.node.id);
			this.chatBuffer.push("I will search to "+(order.node.name||order.node.nameTemporary)+".");
		}
		if( order.verb == 'return' ) {
			this.objective = order.verb;
			this.destinationSet(game.mission.lookup.node.command.id);
			this.chatBuffer.push("Returning.");
		}
		if( order.verb == 'assess' ) {
			this.objective = order.verb;
			this.toAssess = order.patient;
			this.chatBuffer.push("I will assess "+order.patient.name+".");
		}
	}
	canSee(person) {
		return this.nodeId == person.nodeId;
	}
	myNode() {
		return this.land.find(this.nodeId);
	}
	myPlace() {
		if( !this.nextNode ) {
			return this.nodeId;
		}
		let node = this.myNode();
		return node.id<this.nextNode.id ? node.id+'-'+this.nextNode.id : this.nextNode.id+'-'+node.id;
	}
	myTraffic(reversed) {
		if( !this.nextNode ) {
			return '';
		}
		let node = this.myNode();
		return reversed ? this.nextNode.id+'->'+node.id : node.id+'->'+this.nextNode.id;
	}
	onFindPatient(patientsFound) {
		let id = this.id;
		let node = this.myNode();
		this.chatBuffer.push("I found patient"+(patientsFound.length>1?'s':'')+' '+patientsFound.joinMember('name',', ')+(node&&node.name?' in '+node.name:'')+'!');
		$.each( patientsFound, function(index,person) {
			person.foundByPersonId = id;
		});
		let patientsRemaining = game.mission.people.query(function(person) {
			return person.isPatient && !person.foundByPersonId ? person : false;
		});
		if( patientsRemaining.length <= 0 ) {
			this.objective = 'wait';
			this.destinationNodeId = false;
			this.chatBuffer.push("Awaiting further instructions.");
		}
		else {
			this.chatBuffer.push("Should I evac, or keep searching for others?");
			this.objective = 'wait';
			this.destinationNodeId = false;
		}
	}
	onArriveAt() {
		// Check patient rescued
		if( this.isPatient && this.nodeId == game.mission.lookup.node.command.id ) {
			let rescuer = game.mission.people.findWhere('evacuatingPerson',this);
			(rescuer || this).chatBuffer.push("Patient "+this.name+" has been rescued!");
		}
		// Check arrive at search end
		if( this.objective == 'search' && !this.isPatient && this.nodeId == this.destinationNodeId ) {
			this.chatBuffer.push("Arrived at "+this.myNode().name+". Awaiting instructions.");
		}
	}
	speakChatBuffer() {
		while( this.chatBuffer.length > 0 ) {
			let message = this.chatBuffer.shift();
			if( typeof(message) == 'function' ) {
				message = message(this);
			}
			this.chat(message);
		}
	}
	getPersonalMoveSpeed() {
		var moveSpeed = 1.38;	// Human default walk speed
		let issueList = this.getIssueList();
		let issueModifier = 1.0;
		$.each(issueList,function(index,issue) {
			issueModifier = Math.min(issueModifier,issue.speed);
		});
		moveSpeed *= issueModifier;
		if( this.objective == 'search' ) {
			moveSpeed *= 0.5;
		}
		return moveSpeed;
	}
	getMoveSpeed() {
		let moveSpeed = this.getPersonalMoveSpeed();
		if( this.evacuatingPerson ) {
			moveSpeed = Math.min(moveSpeed,this.evacuatingPerson.getPersonalMoveSpeed());
		}
		return moveSpeed;
	}
	getIssueList() {
		let self = this;
		let issueList = [];
		$.each(IssueType,function(issueId,issueType) {
			if( issueType.test.apply(self) ) {
				issueList.push({
					speed: issueType.speed,
					effort: issueType.effort,
					description: issueType.describe.apply(this)
				});
			}
		});
		$.each(this.body.injuryList,function(index,injury) {
			issueList.push({
				severity: injury.severity,
				speed: InjurySeverity[injury.severity].speed,
				effort: InjurySeverity[injury.severity].effort,
				description: "has a "+injury.description
			});
		});
		return issueList;
	}
	textAssess() {
		let s = 'Patient '+this.name+' ';
		let issueList = this.getIssueList();
		s += issueList.joinMember('description',', ');
		return s;
	}

	determineAction() {
		let self = this;
		let nextAction = null;

		function add(id,effortPerSecond,duration,fn) {
			function none(action) { return action.dt; }
			nextAction = {
				id: id,
				effortPerSecond: effortPerSecond,
				duration: duration,
				timeRemaining: duration,
				dt: false,
				onStart: fn.onStart || none,
				onTick: fn.onTick || none,
				onComplete: fn.onComplete || none,
				onAbort: fn.onAbort || none
			};
		}

		function testMove() {
			if( this.destinationNodeId === false || this.destinationNodeId == this.nodeId ) {
				return;
			}
			let path = game.pathFinder.find(this.nodeId,this.destinationNodeId);
			if( path !== false && path.length > 1 && this.nodeId != path[1].id ) {
				var node = this.myNode();
				this.nextNode = path[1];
				let metersPerSec = this.getMoveSpeed();
				let mode = MoveMode[node.to[this.nextNode.id]];
				metersPerSec *= mode.speed;

				add( 'move', mode.effortPerSecond, 99999, {
					onTick: function(action) {

						//this.chatBuffer.push("path: "+path.join('->'));
						this.lastMoveTime = game.clock.time;
						if( !this.nextNode ) throw "getTraffic can not work without a next node.";
						var opposingtraffic = this.land.getTraffic(this.myTraffic(true),this.id);
						this.isAwaitingTraffic = ( opposingtraffic.length && mode.pass == false );
						if( this.isAwaitingTraffic ) {
							return action.dt;
						}
						var distanceRemaining = getMapDistance(this,this.nextNode);
						var distancePossible = (action.dt * metersPerSec)+0.01;	// add 0.01 to handle precision problems.
						if( distancePossible >= distanceRemaining ) {
							this.nodeId = this.nextNode.id;
							this.setPosition(this.nextNode);
							this.onArriveAt(this.nodeId);
							this.nextNode = null;	// means we've arrived, and the hall is clear
							if( this.destinationNextNodeId !== false ) {
								this.destinationNodeId = this.destinationNextNodeId;
								this.destinationNextNodeId = false;
							}

							var timeTaken = action.dt * (distanceRemaining/distancePossible);
							// NASTY HACK - after completing a move, there is some timeRemaining
							// in the action, so we forcibly get rid of it.
							action.timeRemaining = timeTaken;
							return timeTaken;
						}
						var travelPct = (distancePossible/distanceRemaining);
						var dx = this.nextNode.x-this.x;
						var dy = this.nextNode.y-this.y;
						this.setPosition({ x: this.x+(dx*travelPct), y: this.y+(dy*travelPct) });
						return action.dt;
					}
				});
			}
		}

		function testAssessPatient() {
			if( this.objective == 'assess' && this.toAssess ) {
				let patient = this.toAssess;
				this.toAssess = null;
				add('assess', Effort.talk, 30, {
					onComplete: function(action) {
						let message = patient.textAssess();
						self.chatBuffer.push(message);
					}
				});
			}
		}

		function testEvacuatePatient() {
			if( this.objective == 'evacuate' ) {
				//debug.log(this.name+' testing evacuate');
				if( !this.evacuatingPerson ) {
					//debug.log('   and currently evacuating nobody!');
				}
			}
			if( this.objective == 'evacuate' && !this.evacuatingPerson ) {
				$.each(game.mission.people.personList,function(personId,person) {
					if( !self.isPatient && person.isPatient && person.nodeId == self.nodeId ) {
						debug.log('  found '+person.name+' at '+self.nodeId);
						add( 'startEvacuatingPatient', Effort.talk, 30, {
							onStart: function(action) {
								debug.log(self.name+' claiming evac of '+person.name);
								self.chatBuffer.push("I am evacuating "+person.name+" to "+game.mission.land.find(self.destinationNodeId).name+".");
							},
							onComplete: function(action) {
								self.evacuatingPersonCouple(person);
							}
						});
					}
				});
			}
		}
		function testFindPatient() {
			if( !this.isPatient ) {
				let patientsFound = query(game.mission.people.personList,function(person) {
					return self.nodeId == person.nodeId && person.isPatient && !person.foundByPersonId ? person : false;
				});
				if( patientsFound.length > 0 ) {
					add('foundPatient',Effort.talk,10,{
						onStart: function(action) {
							this.onFindPatient(patientsFound);
						}
					});
				}
			}
		}

		let testList = [
			testFindPatient,
			testEvacuatePatient,
			testAssessPatient,
			testMove
		];

		var index = 0;
		while( index < testList.length && nextAction === null ) {
			testList[index].apply(this);
			index += 1;
		}
		if( !nextAction && this.orderList.length ) {
			this.onOrder(this.orderList.shift());
		}
		if( nextAction ) {
			debug.log(this.name+' action='+nextAction.id);
		}
		return nextAction;
	}
	takeAction() {
		let timeRemaining = game.clock.dt;
		let timeout = 1000;
		while( timeRemaining > 0 && --timeout > 0 ) {
			if( this.actionList.length <= 0 || this.actionList[0].id == 'move' ) {
				let nextAction = this.determineAction();
				if( nextAction ) {
					if( this.actionList.length <= 0 || this.actionList[0].id != nextAction.id ) {
						this.actionList[0] = nextAction;
					}
				}
				if( this.actionList.length == 0 ) {
					break;
				}
			}
			var action = this.actionList[0];
			let timeTaken = 0;

			// ON START
			if( action.dt === false ) {
				action.dt = 0;
				action.onStart.apply(this,[action]);
			}
			// ON TICK
			else {
				action.dt = Math.min(action.timeRemaining,timeRemaining);
				this.body.stamina -= (action.effort*(action.dt/action.duration)) / 1000;
				timeTaken = action.onTick.apply(this,[action]);
			}
			// IMPORTANT: only run if the current action was NOT aborted
			if( this.actionList[0] === action ) {
				action.timeRemaining -= timeTaken;
				if( action.timeRemaining <= 0 ) {
					// ON COMPLETE
					action.onComplete.apply(this,[action]);
					if( this.actionList[0] === action ) {
						// Just in cast the action was aborted during onComplete. Should never happen. Famous last words.
						this.actionList.shift();
					}
				}
			}
			timeRemaining -= timeTaken;
		}
		if( timeout <= 0 ) {
			throw "takeAction timed out.";
		}
	}
	tick() {
		this.takeAction();
		this.speakChatBuffer();
	}
}

class Node {
	constructor(data) {
		this.id = data.id;
		this.name = data.name;
		this.isCommand = data.isCommand;
		this.isEntrance = data.isEntrance;
		this.x = data.x;
		this.y = data.y;
		this.to = data.to;
	}
	extent() {
		return { x: this.x, y: this.y };
	}
	render() {
		game.renderer.renderNode(this);
	}
}

class PathFinder {
	constructor(nodeList) {
		this.nodeList = nodeList;
	}
	find(startNodeId,endNodeId) {
		var nodeList = this.nodeList;
		let from = {};
		if( !nodeList[startNodeId] ) throw "pathfind no such starting node "+startNodeId;
		if( !nodeList[endNodeId] ) throw "pathfind no such end node "+endNodeId;

		let count = 0;
		function advance(nodeId,fromNodeId) {
			if( !nodeList[nodeId] ) throw "pathfind no such node "+nodeId;
			from[nodeId] = fromNodeId;
			count += 1;
			$.each(nodeList[nodeId].to,function(toNodeId,mode) {
				if( !nodeList[toNodeId] ) throw "pathfind no such connection from "+nodeId+" to "+toNodeId;
				let toNode = nodeList[toNodeId];
				if( toNode.id != fromNodeId && from[toNode.id] === undefined ) {
					advance(toNodeId,nodeId);
				}
			});
		}
		advance(startNodeId,-1);
		let path = [];
		let nodeId = endNodeId;
		if( from[nodeId] === undefined ) {
			return false;
		}
		do {
			path.unshift(this.nodeList[nodeId]);
			nodeId = from[nodeId];
		} while( nodeId != startNodeId && nodeList[nodeId] && from[nodeId] !== undefined );
		path.unshift(this.nodeList[nodeId]);
		return path;
	}
}

class People {
	constructor(personList,land) {
		this.personList = $.extend(true,{},personList);
		this.teamList = [];
		this.land = land;
		land.people = this;
		$.each(this.personList,function(index,person) {
			person.land = land;
			person.setPosition(person.myNode());
			if( !person.isPatient ) {
				person.isRescuer = true;
			}
			person.visual = {
				rand: Math.PI*2*Math.random(),
				x: false,
				y: false
			};
		});
		$.each(this.personList,function(index,person) {
			person.pitch = 0.5+Math.random()*1.0;
		});
	}
	query(fn) {
		return query(this.personList,fn);
	}
	findWhere(member,value) {
		var found = false;
		$.each( this.personList, function(personId,person) {
			if( person[member] == value ) {
				found = person;
				return false;
			}
		});
		return found;
	}
	find(id) {
		return this.findWhere('id',id);
	}
	teamForm(name,leader,roster) {
		var team = new Team(name,leader);
		$.each(roster,function(index,person) {
			person.team = team;
		});
		this.teamList.push(team);
	}
	teamRoster(teamId) {
		let roster = this.query(function(person) {
			return person.team.id == teamId && person.team.leader !== person;
		});
		roster.unshift(this.teamList[teamId].leader);
		return roster;
	}
	tick() {
		$.each( this.personList, function(personId,person) {
			person.tick();
		});
	}
}

class Land {
	constructor(nodeList,surveyWidth,surveyHeight) {
		var self = this;
		this.people = false;
		this.nodeList = $.extend(true,{},nodeList);
		$.each( this.nodeList, function(nodeId,node) {
			node.x = node.x * surveyWidth / 1000.0;
			node.y = node.y * surveyHeight / 1000.0;
			node.to = node.to || {};
			for( let toNodeId in node.to ) {
				if( !self.nodeList[toNodeId] ) {
					throw "Node "+nodeId+" bad connection "+toNodeId;
				}
				if( MoveMode[self.nodeList[toNodeId]] ) {
					throw "Node "+nodeId+" unknown move mode "+self.nodeList[toNodeId];
				}
				if( !self.nodeList[toNodeId].to[nodeId] ) {
					self.nodeList[toNodeId].to[nodeId] = node.to[toNodeId];
				}
			}
		});
	}
	query(fn) {
		return query(this.nodeList,fn);
	}
	findWhere(member,value) {
		var found = false;
		$.each( this.nodeList, function(nodeId,node) {
			if( node[member] == value ) {
				found = node;
				return false;
			}
		});
		return found;
	}
	find(id) {
		return this.findWhere('id',id);
	}
	getPosition(nodeId) {
		if( !this.nodeList[nodeId] ) throw "Unknown node "+nodeId;
		return { x:this.nodeList[nodeId].x, y:this.nodeList[nodeId].y };
	}
	getOccupants(place,askerId) {	// askedId can be undefined, to get all occupants
		let occupantList = this.people.query(function(person) {
			return person.id != askerId && person.myPlace() == place ? person : false;
		});
		return occupantList;
	}
	// This gets everyone going a certain direction
	getTraffic(traffic,askerId) {	// askedId can be undefined, to get all occupants
		let trafficList = this.people.query(function(person) {
			return person.id != askerId && person.myTraffic() == traffic && !person.isAwaitingTraffic ? person : false;
		});
		return trafficList;
	}
	tick() {
	}
}

class Mission {
	constructor(data){
		this.name = data.name;
		this.survey = data.survey;
		this.land = new Land(data.nodeList,this.survey.width,this.survey.height);
		this.people = new People(data.personList,this.land);
		this.lookup = {
			person: {
				you: this.people.findWhere('isYou',true)
			},
			node: {
				entrance: this.land.findWhere('isEntrance',true),
				command: this.land.findWhere('isCommand',true)
			}
		};

	}
	executeOrder(order) {
		let person = order.person;
		person.orderAdd( order );
	}
	tick() {
		this.people.tick();
		this.land.tick();
		$("#time").text(game.clock.readable());
	}
}

class Whiteboard {
	constructor(people) {
		this.people = people;
	}
	tick() {
		var text = {};
		text['Staging Area'] = [];
		$.each(this.people.personList,function(id,person) {
			if( person.isPatient && !person.foundByPersonId && !debug.showPatient ) {
				return;
			}
			text['Staging Area'].push(person);
		});
		$.each(this.people.teamList,function(id,team) {
			text[team.name] = this.people.getTeamRoster(team.id);
		});
		var html = '';
		$.each(text,function(title,roster) {
			html += "<div class='teamTitle'>"+title+"</div>";
			html += "<div class='teamMember'>"+roster.joinMember('name',"</div><div class='teamMember'>")+"</div>";
		});
		$('#whiteboard').html(html);
	}
}

let VerbList = {
	search: {
		ask:['node']
	},
	evacuate: {
		ask:['patient'],
		disableWhen: function() { return !this.choices.patient || this.choices.patient.length <= 0; }
	},
	return: {
		ask:[],
		disableWhen: function() { return this.order.person && this.order.person.nodeId == game.mission.lookup.node.command.id; }
	},
	assess: {
		ask:['patient'],
		disableWhen: function() { return !this.choices.patient || this.choices.patient.length <= 0; }
	},
	form: {
		ask:['rescuers']
	}
};


class Orders {
	constructor(peopleQuery,landQuery) {
		this.peopleQuery = peopleQuery;
		this.landQuery = landQuery;
		this.order = {};
		this.state = -1;	// 0 means populate, 1/2/3 = stages, 4 means execute
		this.choices = {};
		this.reset();
	}
	reset() {
		this.state = 0;
		this.order.person = null;
		this.order.verb = "";
		this.order.node = null;
		this.order.rescuers = [];
		this.order.patient = null;
		var colId = '#orderChoices';
		$(colId).empty();
	}
	populate() {
		let self = this;
		this.choices.person = this.peopleQuery(function(person) {
			return (!person.isPatient && !person.isYou ? person : false);
		});
		// Any node with a name
		this.peopleQuery(function(person) {
			let node = person.myNode();
			if( person.isPatient && person.foundByPersonId && !node.name ) {
				node.nameTemporary = 'Patient '+person.name;
			}
		});
		this.choices.node = this.landQuery(function(node) {
			return node.name || node.nameTemporary ? node : false;
		});
		this.choices.rescuers = this.peopleQuery(function(person) {
			return (!person.isPatient && !person.team && !person.isYou ? person : false);
		});
		this.choices.patient = this.peopleQuery(function(person) {
			return (person.isPatient && self.order.person && self.order.person.canSee(person) ? person : false);
		});
		// WARNING: must come last, so that choices.patient can be filled first.
		this.choices.verb = query(VerbList,function(verb,key) {
			if( verb.disableWhen && verb.disableWhen.apply(self) ) {
				return "<span class='disableChoice'>"+key+"</span>";
			}
			return key;
		});
	}
	present(column,choices) {
		let colId = '#orderChoices';
		$(colId).empty();
		let self = this;
		$.each(choices,function(index,choice) {
			var text = typeof choice == 'string' ? choice : (choice.name || choice.nameTemporary);
			$("<a src='javascript:void 0' class='choice'>"+text+"</a>")
				.appendTo(colId)
				.click( function() {
					if( self.state == 1 ) { self.order.person = choice; }
					if( self.state == 2 ) { self.order.verb = choice; }
					if( self.state == 3 ) { self.order[VerbList[self.order.verb].ask[0]] = choice; }
					if( self.state == 4 ) { self.order[VerbList[self.order.verb].ask[1]] = choice; }
					if( self.state == 5 ) { self.order[VerbList[self.order.verb].ask[2]] = choice; }
					self.stateAdvance();
				})
				.append("<br />");
		});
	}
	execute() {
		var youList = this.peopleQuery(function(person) { return person.isYou ? person : false; });
		game.chat.add(youList[0],this.summary());
		game.mission.executeOrder(this.order);
		this.reset();
	}
	stateAdvance() {
		this.state += 1;
		if( this.order.verb && this.state > 2+VerbList[this.order.verb].ask.length ) {
			this.execute();
			return;
		}
		this.populate();
		let choiceList = null;
		if( this.state == 1 ) { choiceList = this.choices.person; }
		if( this.state == 2 ) { choiceList = this.choices.verb; }
		if( this.state == 3 ) { choiceList = this.choices[VerbList[this.order.verb].ask[0]]; }
		if( this.state == 4 ) { choiceList = this.choices[VerbList[this.order.verb].ask[1]]; }
		if( this.state == 5 ) { choiceList = this.choices[VerbList[this.order.verb].ask[2]]; }
		this.present(this.state,choiceList);
		this.summarize();
	}
	summary() {
		if( !this.order.person ) {
			return "<i>Click below to enter a command</i>";
		}
		var s = this.order.person.name+' '+this.order.verb;
		if( this.order.node ) {
			s += ' '+this.order.node.name;
		}
		if( this.order.roster ) {
			s += ' '+this.order.roster.joinMember('name',', ');
		}
		return s;
	}
	summarize() {
		$('#orderSummary').html($.trim(this.summary()) || '&nbsp;');
	}
	tick() {
		if( this.state == 0 ) {
			this.stateAdvance();
		}
		this.summarize();
	}
}

class UX {
	constructor() {
		$(document).keydown(function(event) {
			$('#keycode').html(event.keyCode);
			if( event.keyCode == 78 ) { // n
				debug.showNodes = !debug.showNodes;
			}
			if( event.keyCode == 80 ) { // p
				debug.showPatient = !debug.showPatient;
			}
		});
	}
}

class Game {
	constructor(data){
		let self = this;
		this.clock = new Clock(30.0);
		this.mission = data.mission;
		this.pathFinder = new PathFinder(this.mission.land.nodeList);
		this.whiteboard = new Whiteboard(this.mission.people);
		this.chat = new Chat(
			function(id) { return self.mission.people.find(id); }
		);
		this.orders = new Orders(
			function(fn) { return self.mission.people.query(fn); },
			function(fn) { return self.mission.land.query(fn); }
		);
		this.survey = new Survey(data.mission.survey);
		this.map = new Map();
		this.renderer = new Renderer();
		this.ux = new UX();
	}
	render() {
		let renderList = [];
		if( this.survey.loaded ) {
			renderList.push(this.survey);
			$.each(this.mission.people.personList,function(index,person) {
				if( person.isPatient && !person.foundByPersonId && !debug.showPatient ) {
					return;
				}
				renderList.push(person);
			});
			$.each(this.mission.land.nodeList,function(index,node) {
				if( debug.showNodes ) {
					renderList.push(node);
				}
			});
		}
		this.map.renderPrepare();
		this.renderer.setContext(this.map.context);
		this.renderer.render(renderList);
	}
	tick() {
		this.clock.advance();
		this.orders.tick();
		this.whiteboard.tick();
		this.chat.tick();
		this.mission.tick();
	}
}

function giveIds(obj) {
	$.each(obj,function(key,value) {
		obj[key].id = key;
	});
	return obj;
}

function getMissionList() {
	return [
	new Mission({
		name: "proof of concept",
		survey: {
			//url: "WhirlpoolCave.png"
			url: "WhirlpoolCave40PctCropped.png",
			width: 1230,
			height: 930,
			mapScale: (559-489)/10
		},
		personList: giveIds({
			'You': new Person({
				name: "You",
				gender: 'm',
				isYou: true,
				nodeId: 1,
				isPatient: false,
				objective: "command"
			}),
			'BA': new Person({
				name: "Billabob Armadillo",
				gender: 'm',
				nodeId: 1,
				isPatient: false,
				objective: "wait"
			}),
			'G': new Person({
				name: "Greg",
				gender: 'm',
				nodeId: 1,
				isPatient: false,
				objective: "wait"
			}),
			'A': new Person({
				name: "Allan",
				gender: 'm',
				nodeId: 1,
				isPatient: false,
				objective: "wait"
			}),
			'pJ': new Person({
				name: "Josiah",
				gender: 'm',
				nodeId: 'tc',
				isPatient: true,
				body: {
					injuryList: [{severity: InjurySeverity.mustBeHelped.id, description: "sprained left ankle"}]
				},
				objective: "wait"
			}),
			'pK': new Person({
				name: "Kathy",
				gender: 'f',
				nodeId: 'a7',
				isPatient: true,
				body: {
					injuryList: [{severity: InjurySeverity.requiresStretcher.id, description: "broken right tibia"}]
				},
				objective: "wait"
			}),
			'pL': new Person({
				name: "Larry",
				gender: 'f',
				nodeId: '2b',
				isPatient: true,
				isLost: true,
				body: {
					stamina: BodyLevels.staminaExhausted,
					temperature: BodyLevels.temperatureHypothermia,
					injuryList: [{severity: InjurySeverity.canWalk.id, description: "sprained left wrist"}]
				},
				objective: "wander"
			})
		}),
		nodeList: giveIds({
			'1': new Node({
				name: "Incident Command",
				isCommand: true,
				x: 250,
				y: 880,
				to: { 'en': 'walk' }
			}),
			'en': new Node({
				name: "Entrance",
				isEntrance: true,
				x: 67,
				y: 925,
				to: { 'nb': 'stoop' }
			}),
			'nb': new Node({
				name: "Natural Bridge",
				x: 111,
				y: 839,
				to: { '2a': 'walk' }
			}),
			'2a': new Node({
				x: 168,
				y: 781,
				to: { '2b': 'stoop' }
			}),
			'2b': new Node({
				x: 188,
				y: 667,
				to: { '2b1': 'stoop' }
			}),
			'2b1': new Node({
				x: 229,
				y: 650,
				to: { '2c': 'walk' }
			}),
			'2c': new Node({
				x: 254,
				y: 613,
				to: { '2d': 'squeeze' }
			}),
			'2d': new Node({
				x: 293,
				y: 594,
				to: { '2e': 'walk' }
			}),
			'2e': new Node({
				x: 352,
				y: 643,
				to: { 'tc': 'walk' }
			}),
			'tc': new Node({
				name: "Travis Country Room",
				x: 424,
				y: 570,
				to: { 'rr': 'walk', 'b1': 'walk' }
			}),
			'a1': new Node({
				x: 385,
				y: 490,
				to: { 'rr': 'walk' }
			}),
			'rr': new Node({
				name: "Red Room",
				x: 380,
				y: 388,
				to: { 'a2': 'walk' }
			}),
			'a2': new Node({
				x: 353,
				y: 346,
				to: { 'a3': 'walk' }
			}),
			'a3': new Node({
				x: 398,
				y: 245,
				to: { 'a4': 'crawl' }
			}),
			'a4': new Node({
				x: 419,
				y: 258,
				to: { 'a5': 'crawl' }
			}),
			'a5': new Node({
				x: 434,
				y: 234,
				to: { 'a6': 'crawl' }
			}),
			'a6': new Node({
				x: 452,
				y: 211,
				to: { 'a7': 'crawl' }
			}),
			'a7': new Node({
				x: 469,
				y: 225,
				to: { 'a7a': 'crawl', 'a8': 'stoop' }
			}),
			'a7a': new Node({
				x: 464,
				y: 264,
				to: { }
			}),
			'a8': new Node({
				x: 539,
				y: 187,
				to: { 'NT': 'crawl' }
			}),
			'NT': new Node({
				name: "Northeast Terminus",
				x: 539,
				y: 68,
				to: { }
			}),
			'b1': new Node({
				x: 463,
				y: 600,
				to: { 'b2': 'crawl' }
			}),
			'b2': new Node({
				x: 505,
				y: 596,
				to: { 'b3': 'stoop' }
			}),
			'b3': new Node({
				x: 552,
				y: 640,
				to: { 'b4': 'stoop' }
			}),
			'b4': new Node({
				x: 598,
				y: 666,
				to: { 'b5': 'stoop' }
			}),
			'b5': new Node({
				x: 642,
				y: 664,
				to: { 'b6': 'stoop' }
			}),
			'b6': new Node({
				x: 696,
				y: 732,
				to: { 'AL': 'walk' }
			}),
			'AL': new Node({
				name: 'Ant Lion Room',
				x: 707,
				y: 720,
				to: { 'b7': 'walk' }
			}),
			'b7': new Node({
				x: 716,
				y: 690,
				to: { 'b8': 'squeeze' }
			}),
			'b8': new Node({
				x: 769,
				y: 654,
				to: { 'b9': 'walk' }
			}),
			'b9': new Node({
				x: 910,
				y: 714,
				to: { 'b10': 'squeeze' }
			}),
			'b10': new Node({
				x: 901,
				y: 807,
				to: { 'b11': 'walk', 'SR': 'walk' }
			}),
			'b11': new Node({
				x: 857,
				y: 825,
				to: { }
			}),
			'SR': new Node({
				name: 'Surprise Room',
				x: 904,
				y: 879,
				to: { 'b14': 'walk' }
			}),
			'b14': new Node({
				x: 950,
				y: 867,
				to: { 'ST': 'crawl' }
			}),
			'ST': new Node({
				name: "South Terminus",
				x: 962,
				y: 919,
				to: {}
			})
		})
	})
	];
}

$(document).ready(function() {
	game = new Game({
		mission: getMissionList()[0]
	});
	game.clock.start();
	let timer = setInterval(
		function() {
			game.tick();
			game.render();
		}, 250
	)
});
</script>

<div><span id="time"></span></span>&nbsp;&nbsp;<span id="coords"></span> Key: <span id="keycode"></div>
<table style="width: 100%">
<tr>
<td rowspan=3>
	<div id='mapCell' style="width:100%; height:500px;">
	<canvas id="map" width="200" height="120"></canvas>
	</div>
</td>
<td style="width: 40%">
<div id="whiteboard">WHITEBOARD</div>
</td>
</tr><tr>
<td style="width: 40%">
<div id="chat">	</div>
</td>
</tr><tr>
<td style="width: 40%">
<div id="orders">
<div id="orderSummary"></div>
<div id="orderChoices"></div>
</div>
</td>
</tr></table>
